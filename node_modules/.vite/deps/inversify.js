// node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect !== "undefined") {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter, root);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    }
    function makeExporter(target, previous) {
      return function(key, value) {
        Object.defineProperty(target, key, { configurable: true, writable: true, value });
        if (previous)
          previous(key, value);
      };
    }
    function functionThis() {
      try {
        return Function("return this;")();
      } catch (_3) {
      }
    }
    function indirectEvalThis() {
      try {
        return (void 0, eval)("(function() { return this; })()");
      } catch (_3) {
      }
    }
    function sloppyModeThis() {
      return functionThis() || indirectEvalThis();
    }
  })(function(exporter, root) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
      } : function(map, key) {
        return key in map;
      },
      get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : void 0;
      } : function(map, key) {
        return map[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
    var metadataRegistry = GetOrCreateMetadataRegistry();
    var metadataProvider = CreateMetadataProvider(metadataRegistry);
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var provider = GetMetadataProvider(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function OrdinaryHasMetadata(MetadataKey, O3, P3) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O3, P3);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O3);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P3);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O3, P3) {
      var provider = GetMetadataProvider(
        O3,
        P3,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O3, P3));
    }
    function OrdinaryGetMetadata(MetadataKey, O3, P3) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O3, P3);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O3, P3);
      var parent = OrdinaryGetPrototypeOf(O3);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P3);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O3, P3) {
      var provider = GetMetadataProvider(
        O3,
        P3,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return;
      return provider.OrdinaryGetOwnMetadata(MetadataKey, O3, P3);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O3, P3) {
      var provider = GetMetadataProvider(
        O3,
        P3,
        /*Create*/
        true
      );
      provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O3, P3);
    }
    function OrdinaryMetadataKeys(O3, P3) {
      var ownKeys = OrdinaryOwnMetadataKeys(O3, P3);
      var parent = OrdinaryGetPrototypeOf(O3);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P3);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O3, P3) {
      var provider = GetMetadataProvider(
        O3,
        P3,
        /*create*/
        false
      );
      if (!provider) {
        return [];
      }
      return provider.OrdinaryOwnMetadataKeys(O3, P3);
    }
    function Type(x3) {
      if (x3 === null)
        return 1;
      switch (typeof x3) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x3 === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x3) {
      return x3 === void 0;
    }
    function IsNull(x3) {
      return x3 === null;
    }
    function IsSymbol(x3) {
      return typeof x3 === "symbol";
    }
    function IsObject(x3) {
      return typeof x3 === "object" ? x3 !== null : typeof x3 === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O3, hint) {
      if (hint === "string") {
        var toString_1 = O3.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O3);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O3.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O3);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O3.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O3);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O3.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O3);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function SameValueZero(x3, y3) {
      return x3 === y3 || x3 !== x3 && y3 !== y3;
    }
    function GetMethod(V3, P3) {
      var func = V3[P3];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f3 = iterator["return"];
      if (f3)
        f3.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O3) {
      var proto = Object.getPrototypeOf(O3);
      if (typeof O3 !== "function" || O3 === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O3.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O3)
        return proto;
      return constructor;
    }
    function CreateMetadataRegistry() {
      var fallback;
      if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
        fallback = CreateFallbackProvider(root.Reflect);
      }
      var first;
      var second;
      var rest;
      var targetProviderMap = new _WeakMap();
      var registry = {
        registerProvider,
        getProvider,
        setProvider
      };
      return registry;
      function registerProvider(provider) {
        if (!Object.isExtensible(registry)) {
          throw new Error("Cannot add provider to a frozen registry.");
        }
        switch (true) {
          case fallback === provider:
            break;
          case IsUndefined(first):
            first = provider;
            break;
          case first === provider:
            break;
          case IsUndefined(second):
            second = provider;
            break;
          case second === provider:
            break;
          default:
            if (rest === void 0)
              rest = new _Set();
            rest.add(provider);
            break;
        }
      }
      function getProviderNoCache(O3, P3) {
        if (!IsUndefined(first)) {
          if (first.isProviderFor(O3, P3))
            return first;
          if (!IsUndefined(second)) {
            if (second.isProviderFor(O3, P3))
              return first;
            if (!IsUndefined(rest)) {
              var iterator = GetIterator(rest);
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  return void 0;
                }
                var provider = IteratorValue(next);
                if (provider.isProviderFor(O3, P3)) {
                  IteratorClose(iterator);
                  return provider;
                }
              }
            }
          }
        }
        if (!IsUndefined(fallback) && fallback.isProviderFor(O3, P3)) {
          return fallback;
        }
        return void 0;
      }
      function getProvider(O3, P3) {
        var providerMap = targetProviderMap.get(O3);
        var provider;
        if (!IsUndefined(providerMap)) {
          provider = providerMap.get(P3);
        }
        if (!IsUndefined(provider)) {
          return provider;
        }
        provider = getProviderNoCache(O3, P3);
        if (!IsUndefined(provider)) {
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O3, providerMap);
          }
          providerMap.set(P3, provider);
        }
        return provider;
      }
      function hasProvider(provider) {
        if (IsUndefined(provider))
          throw new TypeError();
        return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
      }
      function setProvider(O3, P3, provider) {
        if (!hasProvider(provider)) {
          throw new Error("Metadata provider not registered.");
        }
        var existingProvider = getProvider(O3, P3);
        if (existingProvider !== provider) {
          if (!IsUndefined(existingProvider)) {
            return false;
          }
          var providerMap = targetProviderMap.get(O3);
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O3, providerMap);
          }
          providerMap.set(P3, provider);
        }
        return true;
      }
    }
    function GetOrCreateMetadataRegistry() {
      var metadataRegistry2;
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        metadataRegistry2 = root.Reflect[registrySymbol];
      }
      if (IsUndefined(metadataRegistry2)) {
        metadataRegistry2 = CreateMetadataRegistry();
      }
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        Object.defineProperty(root.Reflect, registrySymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: metadataRegistry2
        });
      }
      return metadataRegistry2;
    }
    function CreateMetadataProvider(registry) {
      var metadata2 = new _WeakMap();
      var provider = {
        isProviderFor: function(O3, P3) {
          var targetMetadata = metadata2.get(O3);
          if (IsUndefined(targetMetadata))
            return false;
          return targetMetadata.has(P3);
        },
        OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
        OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
        OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
        OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
        OrdinaryDeleteMetadata
      };
      metadataRegistry.registerProvider(provider);
      return provider;
      function GetOrCreateMetadataMap(O3, P3, Create) {
        var targetMetadata = metadata2.get(O3);
        var createdTargetMetadata = false;
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          metadata2.set(O3, targetMetadata);
          createdTargetMetadata = true;
        }
        var metadataMap = targetMetadata.get(P3);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P3, metadataMap);
          if (!registry.setProvider(O3, P3, provider)) {
            targetMetadata.delete(P3);
            if (createdTargetMetadata) {
              metadata2.delete(O3);
            }
            throw new Error("Wrong provider for target.");
          }
        }
        return metadataMap;
      }
      function OrdinaryHasOwnMetadata2(MetadataKey, O3, P3) {
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P3,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetOwnMetadata2(MetadataKey, O3, P3) {
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P3,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O3, P3) {
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P3,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      function OrdinaryOwnMetadataKeys2(O3, P3) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P3,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k3 = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (!next) {
            keys.length = k3;
            return keys;
          }
          var nextValue = IteratorValue(next);
          try {
            keys[k3] = nextValue;
          } catch (e2) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e2;
            }
          }
          k3++;
        }
      }
      function OrdinaryDeleteMetadata(MetadataKey, O3, P3) {
        var metadataMap = GetOrCreateMetadataMap(
          O3,
          P3,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(MetadataKey))
          return false;
        if (metadataMap.size === 0) {
          var targetMetadata = metadata2.get(O3);
          if (!IsUndefined(targetMetadata)) {
            targetMetadata.delete(P3);
            if (targetMetadata.size === 0) {
              metadata2.delete(targetMetadata);
            }
          }
        }
        return true;
      }
    }
    function CreateFallbackProvider(reflect) {
      var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
      var metadataOwner = new _WeakMap();
      var provider = {
        isProviderFor: function(O3, P3) {
          var metadataPropertySet = metadataOwner.get(O3);
          if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P3)) {
            return true;
          }
          if (getOwnMetadataKeys2(O3, P3).length) {
            if (IsUndefined(metadataPropertySet)) {
              metadataPropertySet = new _Set();
              metadataOwner.set(O3, metadataPropertySet);
            }
            metadataPropertySet.add(P3);
            return true;
          }
          return false;
        },
        OrdinaryDefineOwnMetadata: defineMetadata2,
        OrdinaryHasOwnMetadata: hasOwnMetadata2,
        OrdinaryGetOwnMetadata: getOwnMetadata2,
        OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
        OrdinaryDeleteMetadata: deleteMetadata2
      };
      return provider;
    }
    function GetMetadataProvider(O3, P3, Create) {
      var registeredProvider = metadataRegistry.getProvider(O3, P3);
      if (!IsUndefined(registeredProvider)) {
        return registeredProvider;
      }
      if (Create) {
        if (metadataRegistry.setProvider(O3, P3, metadataProvider)) {
          return metadataProvider;
        }
        throw new Error("Illegal state.");
      }
      return void 0;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }()
      );
      var Map2 = (
        /** @class */
        function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map3.prototype.set = function(key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i = 0; i < this._keys.length; i++) {
                if (SameValueZero(this._keys[i], key)) {
                  this._cacheIndex = i;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map3;
        }()
      );
      return Map2;
      function getKey(key, _3) {
        return key;
      }
      function getValue(_3, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      var Set2 = (
        /** @class */
        function() {
          function Set3() {
            this._map = new _Map();
          }
          Object.defineProperty(Set3.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set3.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set3.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set3.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set3.prototype.clear = function() {
            this._map.clear();
          };
          Set3.prototype.keys = function() {
            return this._map.keys();
          };
          Set3.prototype.values = function() {
            return this._map.keys();
          };
          Set3.prototype.entries = function() {
            return this._map.entries();
          };
          Set3.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set3;
        }()
      );
      return Set2;
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i)
          buffer[i] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          var array = new Uint8Array(size);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(array);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(array);
          } else {
            FillRandomBytes(array, size);
          }
          return array;
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// node_modules/@inversifyjs/common/lib/esm/index.js
function e(e2) {
  return ("object" == typeof e2 && null !== e2 || "function" == typeof e2) && "function" == typeof e2.then;
}
function t(e2) {
  switch (typeof e2) {
    case "string":
    case "symbol":
      return e2.toString();
    case "function":
      return e2.name;
    default:
      throw new Error(`Unexpected ${typeof e2} service id type`);
  }
}
var n = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
var r = class {
  [n];
  #e;
  constructor(e2) {
    this.#e = e2, this[n] = true;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[n];
  }
  unwrap() {
    return this.#e();
  }
};

// node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js
function t2(t4, e2) {
  return Reflect.getOwnMetadata(e2, t4);
}
function n2(t4, e2, n3) {
  Reflect.defineMetadata(e2, n3, t4);
}
function a(e2, n3, a2, f3) {
  const c2 = f3(t2(e2, n3) ?? a2());
  Reflect.defineMetadata(n3, c2, e2);
}

// node_modules/@inversifyjs/prototype-utils/lib/esm/index.js
function t3(t4) {
  const o = Object.getPrototypeOf(t4.prototype), r2 = o?.constructor;
  return r2;
}

// node_modules/@inversifyjs/core/lib/esm/index.js
var s = { Request: "Request", Singleton: "Singleton", Transient: "Transient" };
var c = { ConstantValue: "ConstantValue", DynamicValue: "DynamicValue", Factory: "Factory", Instance: "Instance", Provider: "Provider", ResolvedValue: "ResolvedValue", ServiceRedirection: "ServiceRedirection" };
function* u(...e2) {
  for (const t4 of e2) yield* t4;
}
var d = class _d {
  #e;
  #t;
  #n;
  constructor(e2) {
    this.#e = /* @__PURE__ */ new Map(), this.#t = {};
    for (const t4 of Reflect.ownKeys(e2)) this.#t[t4] = /* @__PURE__ */ new Map();
    this.#n = e2;
  }
  add(e2, t4) {
    this.#i(e2).push(t4);
    for (const n3 of Reflect.ownKeys(t4)) this.#o(n3, t4[n3]).push(e2);
  }
  clone() {
    const e2 = Reflect.ownKeys(this.#n), t4 = new _d(this.#n);
    this.#r(this.#e, t4.#e);
    for (const n3 of e2) this.#r(this.#t[n3], t4.#t[n3]);
    return t4;
  }
  get(e2, t4) {
    return this.#t[e2].get(t4);
  }
  getAllKeys(e2) {
    return this.#t[e2].keys();
  }
  removeByRelation(e2, t4) {
    const n3 = this.get(e2, t4);
    if (void 0 === n3) return;
    const i = new Set(n3);
    for (const n4 of i) {
      const i2 = this.#e.get(n4);
      if (void 0 === i2) throw new Error("Expecting model relation, none found");
      for (const o of i2) o[e2] === t4 && this.#a(n4, o);
      this.#e.delete(n4);
    }
  }
  #i(e2) {
    let t4 = this.#e.get(e2);
    return void 0 === t4 && (t4 = [], this.#e.set(e2, t4)), t4;
  }
  #o(e2, t4) {
    let n3 = this.#t[e2].get(t4);
    return void 0 === n3 && (n3 = [], this.#t[e2].set(t4, n3)), n3;
  }
  #r(e2, t4) {
    for (const [n3, i] of e2) t4.set(n3, [...i]);
  }
  #a(e2, t4) {
    for (const n3 of Reflect.ownKeys(t4)) this.#s(e2, n3, t4[n3]);
  }
  #s(e2, t4, n3) {
    const i = this.#t[t4].get(n3);
    if (void 0 !== i) {
      const o = i.indexOf(e2);
      -1 !== o && i.splice(o, 1), 0 === i.length && this.#t[t4].delete(n3);
    }
  }
};
var l;
var p;
var f;
!function(e2) {
  e2.moduleId = "moduleId", e2.serviceId = "serviceId";
}(l || (l = {}));
var g = class _g {
  #c;
  #u;
  constructor(e2, t4) {
    this.#c = t4 ?? new d({ moduleId: { isOptional: true }, serviceId: { isOptional: false } }), this.#u = e2;
  }
  static build(e2) {
    return new _g(e2);
  }
  add(e2, t4) {
    this.#c.add(e2, t4);
  }
  clone() {
    return new _g(this.#u, this.#c.clone());
  }
  get(e2) {
    const t4 = [], n3 = this.#c.get(l.serviceId, e2);
    void 0 !== n3 && t4.push(n3);
    const i = this.#u?.get(e2);
    if (void 0 !== i && t4.push(i), 0 !== t4.length) return u(...t4);
  }
  removeAllByModuleId(e2) {
    this.#c.removeByRelation(l.moduleId, e2);
  }
  removeAllByServiceId(e2) {
    this.#c.removeByRelation(l.serviceId, e2);
  }
};
!function(e2) {
  e2.moduleId = "moduleId", e2.serviceId = "serviceId";
}(p || (p = {}));
var m = class _m {
  #d;
  #u;
  constructor(e2, t4) {
    this.#d = t4 ?? new d({ moduleId: { isOptional: true }, serviceId: { isOptional: false } }), this.#u = e2;
  }
  static build(e2) {
    return new _m(e2);
  }
  clone() {
    return new _m(this.#u, this.#d.clone());
  }
  get(e2) {
    return this.getNonParentBindings(e2) ?? this.#u?.get(e2);
  }
  getNonParentBindings(e2) {
    return this.#d.get(p.serviceId, e2);
  }
  getNonParentBoundServices() {
    return this.#d.getAllKeys(p.serviceId);
  }
  getByModuleId(e2) {
    return this.#d.get(p.moduleId, e2) ?? this.#u?.getByModuleId(e2);
  }
  removeAllByModuleId(e2) {
    this.#d.removeByRelation(p.moduleId, e2);
  }
  removeAllByServiceId(e2) {
    this.#d.removeByRelation(p.serviceId, e2);
  }
  set(e2) {
    const t4 = { [p.serviceId]: e2.serviceIdentifier };
    void 0 !== e2.moduleId && (t4[p.moduleId] = e2.moduleId), this.#d.add(e2, t4);
  }
};
!function(e2) {
  e2.moduleId = "moduleId", e2.serviceId = "serviceId";
}(f || (f = {}));
var h = class _h {
  #l;
  #u;
  constructor(e2, t4) {
    this.#l = t4 ?? new d({ moduleId: { isOptional: true }, serviceId: { isOptional: false } }), this.#u = e2;
  }
  static build(e2) {
    return new _h(e2);
  }
  add(e2, t4) {
    this.#l.add(e2, t4);
  }
  clone() {
    return new _h(this.#u, this.#l.clone());
  }
  get(e2) {
    const t4 = [], n3 = this.#l.get(f.serviceId, e2);
    void 0 !== n3 && t4.push(n3);
    const i = this.#u?.get(e2);
    if (void 0 !== i && t4.push(i), 0 !== t4.length) return u(...t4);
  }
  removeAllByModuleId(e2) {
    this.#l.removeByRelation(f.moduleId, e2);
  }
  removeAllByServiceId(e2) {
    this.#l.removeByRelation(f.serviceId, e2);
  }
};
function v(e2, t4, n3) {
  const i = Array.isArray(e2) ? e2 : [e2];
  if (void 0 !== n3) if ("number" != typeof n3) Reflect.decorate(i, t4.prototype, n3);
  else for (const e3 of i) e3(t4, void 0, n3);
  else Reflect.decorate(i, t4);
}
var y = "@inversifyjs/core/classMetadataReflectKey";
function M() {
  return { constructorArguments: [], lifecycle: { postConstructMethodName: void 0, preDestroyMethodName: void 0 }, properties: /* @__PURE__ */ new Map(), scope: void 0 };
}
var I = "@inversifyjs/core/pendingClassMetadataCountReflectKey";
var w = Symbol.for("@inversifyjs/core/InversifyCoreError");
var b = class _b extends Error {
  [w];
  kind;
  constructor(e2, t4, n3) {
    super(t4, n3), this[w] = true, this.kind = e2;
  }
  static is(e2) {
    return "object" == typeof e2 && null !== e2 && true === e2[w];
  }
  static isErrorOfKind(e2, t4) {
    return _b.is(e2) && e2.kind === t4;
  }
};
var j;
var T;
var C;
function S(t4) {
  const n3 = t2(t4, y) ?? M();
  if (!function(t5) {
    const n4 = t2(t5, I);
    return void 0 !== n4 && 0 !== n4;
  }(t4)) return function(e2, t5) {
    const n4 = [];
    if (t5.length < e2.length) throw new b(j.missingInjectionDecorator, `Found unexpected missing metadata on type "${e2.name}". "${e2.name}" constructor requires at least ${e2.length.toString()} arguments, found ${t5.length.toString()} instead.
Are you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
    for (let e3 = 0; e3 < t5.length; ++e3) void 0 === t5[e3] && n4.push(e3);
    if (n4.length > 0) throw new b(j.missingInjectionDecorator, `Found unexpected missing metadata on type "${e2.name}" at constructor indexes "${n4.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
  }(t4, n3.constructorArguments), n3;
  !function(e2, t5) {
    const n4 = [];
    for (let i = 0; i < t5.constructorArguments.length; ++i) {
      const o = t5.constructorArguments[i];
      void 0 !== o && o.kind !== T.unknown || n4.push(`  - Missing or incomplete metadata for type "${e2.name}" at constructor argument with index ${i.toString()}.
Every constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`);
    }
    for (const [i, o] of t5.properties) o.kind === T.unknown && n4.push(`  - Missing or incomplete metadata for type "${e2.name}" at property "${i.toString()}".
This property must be decorated either with @inject or @multiInject decorator.`);
    if (0 === n4.length) throw new b(j.unknown, `Unexpected class metadata for type "${e2.name}" with uncompletion traces.
This might be caused by one of the following reasons:

1. A third party library is targeting inversify reflection metadata.
2. A bug is causing the issue. Consider submiting an issue to fix it.`);
    throw new b(j.missingInjectionDecorator, `Invalid class metadata at type ${e2.name}:

${n4.join("\n\n")}`);
  }(t4, n3);
}
function A() {
  return 0;
}
function $(e2) {
  return (n3) => {
    void 0 !== n3 && n3.kind === T.unknown && a(e2, I, A, (e3) => e3 - 1);
  };
}
function x(e2, t4) {
  return (...n3) => (i) => {
    if (void 0 === i) return e2(...n3);
    if (i.kind === C.unmanaged) throw new b(j.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
    return t4(i, ...n3);
  };
}
function B(e2) {
  if (e2.kind !== T.unknown && true !== e2.isFromTypescriptParamType) throw new b(j.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
}
!function(e2) {
  e2[e2.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", e2[e2.missingInjectionDecorator = 1] = "missingInjectionDecorator", e2[e2.planning = 2] = "planning", e2[e2.resolution = 3] = "resolution", e2[e2.unknown = 4] = "unknown";
}(j || (j = {})), function(e2) {
  e2[e2.unknown = 32] = "unknown";
}(T || (T = {})), function(e2) {
  e2[e2.multipleInjection = 0] = "multipleInjection", e2[e2.singleInjection = 1] = "singleInjection", e2[e2.unmanaged = 2] = "unmanaged";
}(C || (C = {}));
var R = x(function(e2, t4) {
  return { kind: e2, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: t4 };
}, function(e2, t4, n3) {
  return B(e2), { ...e2, kind: t4, value: n3 };
});
function k(e2, t4) {
  return (n3) => {
    const i = n3.properties.get(t4);
    return n3.properties.set(t4, e2(i)), n3;
  };
}
var P;
function D(e2, t4, n3, i) {
  if (b.isErrorOfKind(i, j.injectionDecoratorConflict)) {
    const o = function(e3, t5, n4) {
      if (void 0 === n4) {
        if (void 0 === t5) throw new b(j.unknown, "Unexpected undefined property and index values");
        return { kind: P.property, property: t5, targetClass: e3.constructor };
      }
      return "number" == typeof n4 ? { index: n4, kind: P.parameter, targetClass: e3 } : { kind: P.method, method: t5, targetClass: e3 };
    }(e2, t4, n3);
    throw new b(j.injectionDecoratorConflict, `Unexpected injection error.

Cause:

${i.message}

Details

${function(e3) {
      switch (e3.kind) {
        case P.method:
          return `[class: "${e3.targetClass.name}", method: "${e3.method.toString()}"]`;
        case P.parameter:
          return `[class: "${e3.targetClass.name}", index: "${e3.index.toString()}"]`;
        case P.property:
          return `[class: "${e3.targetClass.name}", property: "${e3.property.toString()}"]`;
      }
    }(o)}`, { cause: i });
  }
  throw i;
}
function V(e2, n3) {
  return (i, o, r2) => {
    try {
      void 0 === r2 ? function(e3, n4) {
        const i2 = F(e3, n4);
        return (e4, n5) => {
          a(e4.constructor, y, M, k(i2(e4), n5));
        };
      }(e2, n3)(i, o) : "number" == typeof r2 ? function(e3, n4) {
        const i2 = F(e3, n4);
        return (e4, n5, o2) => {
          if (!/* @__PURE__ */ function(e5, t4) {
            return "function" == typeof e5 && void 0 === t4;
          }(e4, n5)) throw new b(j.injectionDecoratorConflict, `Found an @inject decorator in a non constructor parameter.
Found @inject decorator at method "${n5?.toString() ?? ""}" at class "${e4.constructor.name}"`);
          a(e4, y, M, /* @__PURE__ */ function(e5, t4) {
            return (n6) => {
              const i3 = n6.constructorArguments[t4];
              return n6.constructorArguments[t4] = e5(i3), n6;
            };
          }(i2(e4), o2));
        };
      }(e2, n3)(i, o, r2) : function(e3, n4) {
        const i2 = F(e3, n4);
        return (e4, n5, o2) => {
          if (!function(e5) {
            return void 0 !== e5.set;
          }(o2)) throw new b(j.injectionDecoratorConflict, `Found an @inject decorator in a non setter property method.
Found @inject decorator at method "${n5.toString()}" at class "${e4.constructor.name}"`);
          a(e4.constructor, y, M, k(i2(e4), n5));
        };
      }(e2, n3)(i, o, r2);
    } catch (e3) {
      D(i, o, r2, e3);
    }
  };
}
function F(e2, t4) {
  return (n3) => {
    const i = t4(n3);
    return (t5) => (i(t5), e2(t5));
  };
}
function O(e2) {
  return V(R(C.singleInjection, e2), $);
}
!function(e2) {
  e2[e2.method = 0] = "method", e2[e2.parameter = 1] = "parameter", e2[e2.property = 2] = "property";
}(P || (P = {}));
var N = "@inversifyjs/core/classIsInjectableFlagReflectKey";
var E = [Array, BigInt, Boolean, Function, Number, Object, String];
function U(n3) {
  const i = t2(n3, "design:paramtypes");
  void 0 !== i && a(n3, y, M, /* @__PURE__ */ function(e2) {
    return (t4) => (e2.forEach((e3, n4) => {
      var i2;
      void 0 !== t4.constructorArguments[n4] || (i2 = e3, E.includes(i2)) || (t4.constructorArguments[n4] = function(e4) {
        return { isFromTypescriptParamType: true, kind: C.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: e4 };
      }(e3));
    }), t4);
  }(i));
}
function K(i) {
  return (o) => {
    !function(t4) {
      if (void 0 !== t2(t4, N)) throw new b(j.injectionDecoratorConflict, `Cannot apply @injectable decorator multiple times at class "${t4.name}"`);
      n2(t4, N, true);
    }(o), U(o), void 0 !== i && a(o, y, M, (e2) => ({ ...e2, scope: i }));
  };
}
function q(e2, t4, n3) {
  let i;
  return e2.extendConstructorArguments ?? true ? (i = [...t4.constructorArguments], n3.constructorArguments.map((e3, t5) => {
    i[t5] = e3;
  })) : i = n3.constructorArguments, i;
}
function z(e2, t4, n3) {
  let i;
  return i = e2.extendProperties ?? true ? new Map(u(t4.properties, n3.properties)) : n3.properties, i;
}
function G(e2) {
  return (n3) => {
    const i = S(e2.type);
    a(n3, y, M, /* @__PURE__ */ function(e3, t4) {
      const n4 = (n5) => ({ constructorArguments: q(e3, t4, n5), lifecycle: n5.lifecycle, properties: z(e3, t4, n5), scope: n5.scope });
      return n4;
    }(e2, i));
  };
}
function H(e2) {
  return (t4) => {
    const n3 = t3(t4);
    if (void 0 === n3) throw new b(j.injectionDecoratorConflict, `Expected base type for type "${t4.name}", none found.`);
    G({ ...e2, type: n3 })(t4);
  };
}
function J(e2) {
  return V(R(C.multipleInjection, e2), $);
}
function L(e2) {
  return (n3) => {
    void 0 === n3 && a(e2, I, A, (e3) => e3 + 1);
  };
}
function Q(e2) {
  return (t4) => {
    const n3 = t4 ?? { kind: T.unknown, name: void 0, optional: false, tags: /* @__PURE__ */ new Map() };
    if (n3.kind === C.unmanaged) throw new b(j.injectionDecoratorConflict, "Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");
    return e2(n3);
  };
}
function W(e2) {
  const t4 = Q(/* @__PURE__ */ function(e3) {
    return (t5) => {
      if (void 0 !== t5.name) throw new b(j.injectionDecoratorConflict, "Unexpected duplicated named decorator");
      return t5.name = e3, t5;
    };
  }(e2));
  return V(t4, L);
}
function X(e2) {
  if (e2.optional) throw new b(j.injectionDecoratorConflict, "Unexpected duplicated optional decorator");
  return e2.optional = true, e2;
}
function Y() {
  return V(Q(X), L);
}
function Z() {
  return (e2, n3, i) => {
    try {
      a(e2.constructor, y, M, (o = n3, (e3) => {
        if (void 0 !== e3.lifecycle.postConstructMethodName) throw new b(j.injectionDecoratorConflict, "Unexpected duplicated postConstruct decorator");
        return e3.lifecycle.postConstructMethodName = o, e3;
      }));
    } catch (t4) {
      D(e2, n3, void 0, t4);
    }
    var o;
  };
}
function _() {
  return (e2, n3, i) => {
    try {
      a(e2.constructor, y, M, (o = n3, (e3) => {
        if (void 0 !== e3.lifecycle.preDestroyMethodName) throw new b(j.injectionDecoratorConflict, "Unexpected duplicated preDestroy decorator");
        return e3.lifecycle.preDestroyMethodName = o, e3;
      }));
    } catch (t4) {
      D(e2, n3, void 0, t4);
    }
    var o;
  };
}
function ee(e2, t4) {
  const n3 = Q(/* @__PURE__ */ function(e3, t5) {
    return (n4) => {
      if (n4.tags.has(e3)) throw new b(j.injectionDecoratorConflict, "Unexpected duplicated tag decorator with existing tag");
      return n4.tags.set(e3, t5), n4;
    };
  }(e2, t4));
  return V(n3, L);
}
function te() {
  return { kind: C.unmanaged };
}
var ne = x(te, function(e2) {
  if (B(e2), function(e3) {
    return void 0 !== e3.name || e3.optional || e3.tags.size > 0;
  }(e2)) throw new b(j.injectionDecoratorConflict, "Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");
  return te();
});
function ie() {
  return V(ne(), $);
}
var oe;
!function(e2) {
  e2[e2.multipleInjection = 0] = "multipleInjection", e2[e2.singleInjection = 1] = "singleInjection";
}(oe || (oe = {}));
var re = class _re {
  #p;
  constructor(e2) {
    this.#p = e2;
  }
  get name() {
    return this.#p.elem.name;
  }
  get serviceIdentifier() {
    return this.#p.elem.serviceIdentifier;
  }
  get tags() {
    return this.#p.elem.tags;
  }
  getAncestor() {
    if (void 0 !== this.#p.previous) return new _re(this.#p.previous);
  }
};
var ae = class _ae {
  last;
  constructor(e2) {
    this.last = e2;
  }
  concat(e2) {
    return new _ae({ elem: e2, previous: this.last });
  }
  [Symbol.iterator]() {
    let e2 = this.last;
    return { next: () => {
      if (void 0 === e2) return { done: true, value: void 0 };
      const t4 = e2.elem;
      return e2 = e2.previous, { done: false, value: t4 };
    } };
  }
};
function se(e2, t4) {
  e2.servicesBranch.has(t4) && function(e3, t5) {
    const n3 = (i = [...e3.servicesBranch, t5], [...i].map(t).join(" -> "));
    var i;
    throw new b(j.planning, `Circular dependency found: ${n3}`);
  }(e2, t4), e2.servicesBranch.add(t4);
}
function ce(e2, t4, n3) {
  const i = n3?.customServiceIdentifier ?? t4.serviceIdentifier, o = [...e2.getBindings(i) ?? []].filter((e3) => e3.isSatisfiedBy(t4));
  if (0 === o.length && void 0 !== e2.autobindOptions && "function" == typeof i) {
    const t5 = function(e3, t6) {
      return { cache: { isRight: false, value: void 0 }, id: 0, implementationType: t6, isSatisfiedBy: () => true, moduleId: void 0, onActivation: void 0, onDeactivation: void 0, scope: e3.scope, serviceIdentifier: t6, type: c.Instance };
    }(e2.autobindOptions, i);
    e2.setBinding(t5), o.push(t5);
  }
  return o;
}
function ue(e2) {
  return void 0 !== e2.redirections;
}
function de(e2, t4, n3, i) {
  let r2, a2;
  ue(n3) ? (r2 = n3.binding.targetServiceIdentifier, a2 = n3.binding.serviceIdentifier) : (r2 = n3.serviceIdentifier, a2 = n3.parent?.binding.serviceIdentifier), Array.isArray(e2) ? function(e3, t5, n4, i2, r3) {
    if (0 !== e3.length) {
      const t6 = `Ambiguous bindings found for service: "${t(n4)}".

Registered bindings:

${e3.map((e4) => function(e5) {
        switch (e5.type) {
          case c.Instance:
            return `[ type: "${e5.type}", serviceIdentifier: "${t(e5.serviceIdentifier)}", scope: "${e5.scope}", implementationType: "${e5.implementationType.name}" ]`;
          case c.ServiceRedirection:
            return `[ type: "${e5.type}", serviceIdentifier: "${t(e5.serviceIdentifier)}", redirection: "${t(e5.targetServiceIdentifier)}" ]`;
          default:
            return `[ type: "${e5.type}", serviceIdentifier: "${t(e5.serviceIdentifier)}", scope: "${e5.scope}" ]`;
        }
      }(e4.binding)).join("\n")}

Trying to resolve bindings for "${pe(n4, i2)}".

${fe(r3)}`;
      throw new b(j.planning, t6);
    }
    t5 || le(n4, i2, r3);
  }(e2, t4, r2, a2, i) : function(e3, t5, n4, i2, o) {
    if (void 0 !== e3 || t5) return;
    le(n4, i2, o);
  }(e2, t4, r2, a2, i);
}
function le(e2, t4, n3) {
  const i = `No bindings found for service: "${t(e2)}".

Trying to resolve bindings for "${pe(e2, t4)}".

${fe(n3)}`;
  throw new b(j.planning, i);
}
function pe(e2, t4) {
  return void 0 === t4 ? `${t(e2)} (Root service)` : t(t4);
}
function fe(e2) {
  const t4 = 0 === e2.tags.size ? "" : `
- tags:
  - ${[...e2.tags.keys()].map((e3) => e3.toString()).join("\n  - ")}`;
  return `Binding constraints:
- service identifier: ${t(e2.serviceIdentifier)}
- name: ${e2.name?.toString() ?? "-"}${t4}`;
}
function ge(e2, t4, n3) {
  if (1 !== e2.redirections.length) de(e2.redirections, t4, e2, n3);
  else {
    const [i] = e2.redirections;
    ue(i) && ge(i, t4, n3);
  }
}
function me(e2, t4, n3) {
  if (Array.isArray(e2.bindings) && 1 === e2.bindings.length) {
    const [i] = e2.bindings;
    ue(i) && ge(i, t4, n3);
  } else de(e2.bindings, t4, e2, n3);
}
function he(e2) {
  const t4 = /* @__PURE__ */ new Map();
  void 0 !== e2.rootConstraints.tag && t4.set(e2.rootConstraints.tag.key, e2.rootConstraints.tag.value);
  const n3 = new ae({ elem: { name: e2.rootConstraints.name, serviceIdentifier: e2.rootConstraints.serviceIdentifier, tags: t4 }, previous: void 0 }), i = new re(n3.last), o = ce(e2, i), r2 = [], a2 = { bindings: r2, parent: void 0, serviceIdentifier: e2.rootConstraints.serviceIdentifier };
  if (r2.push(...we(e2, n3, o, a2)), !e2.rootConstraints.isMultiple) {
    me(a2, e2.rootConstraints.isOptional ?? false, i);
    const [t5] = r2;
    a2.bindings = t5;
  }
  return { tree: { root: a2 } };
}
function ve(e2, t4, n3, i) {
  const o = { binding: t4, classMetadata: e2.getClassMetadata(t4.implementationType), constructorParams: [], parent: i, propertyParams: /* @__PURE__ */ new Map() };
  return je({ autobindOptions: e2.autobindOptions, getBindings: e2.getBindings, getClassMetadata: e2.getClassMetadata, node: o, servicesBranch: e2.servicesBranch, setBinding: e2.setBinding }, n3);
}
function ye(e2, t4, n3) {
  if (n3.kind === C.unmanaged) return;
  const i = r.is(n3.value) ? n3.value.unwrap() : n3.value, o = t4.concat({ name: n3.name, serviceIdentifier: i, tags: n3.tags }), a2 = new re(o.last), s2 = ce(e2, a2), c2 = [], u2 = { bindings: c2, parent: e2.node, serviceIdentifier: i };
  if (c2.push(...we(e2, o, s2, u2)), n3.kind === C.singleInjection) {
    me(u2, n3.optional, a2);
    const [e3] = c2;
    u2.bindings = e3;
  }
  return u2;
}
function Me(e2, t4, n3) {
  const i = r.is(n3.value) ? n3.value.unwrap() : n3.value, o = t4.concat({ name: n3.name, serviceIdentifier: i, tags: n3.tags }), a2 = new re(o.last), s2 = ce(e2, a2), c2 = [], u2 = { bindings: c2, parent: e2.node, serviceIdentifier: i };
  if (c2.push(...we(e2, o, s2, u2)), n3.kind === oe.singleInjection) {
    me(u2, n3.optional, a2);
    const [e3] = c2;
    u2.bindings = e3;
  }
  return u2;
}
function Ie(e2, t4, n3, i) {
  const o = { binding: t4, params: [], parent: i };
  return je({ autobindOptions: e2.autobindOptions, getBindings: e2.getBindings, getClassMetadata: e2.getClassMetadata, node: o, servicesBranch: e2.servicesBranch, setBinding: e2.setBinding }, n3);
}
function we(e2, t4, n3, i) {
  const o = ue(i) ? i.binding.targetServiceIdentifier : i.serviceIdentifier;
  se(e2, o);
  const r2 = [];
  for (const o2 of n3) switch (o2.type) {
    case c.Instance:
      r2.push(ve(e2, o2, t4, i));
      break;
    case c.ResolvedValue:
      r2.push(Ie(e2, o2, t4, i));
      break;
    case c.ServiceRedirection: {
      const n4 = be(e2, t4, o2, i);
      r2.push(n4);
      break;
    }
    default:
      r2.push({ binding: o2, parent: i });
  }
  return e2.servicesBranch.delete(o), r2;
}
function be(e2, t4, n3, i) {
  const o = { binding: n3, parent: i, redirections: [] }, r2 = ce(e2, new re(t4.last), { customServiceIdentifier: n3.targetServiceIdentifier });
  return o.redirections.push(...we(e2, t4, r2, o)), o;
}
function je(e2, t4) {
  return e2.node.binding.type === c.Instance ? function(e3, t5, n3) {
    const i = t5.classMetadata;
    for (const [o, r2] of i.constructorArguments.entries()) t5.constructorParams[o] = ye(e3, n3, r2);
    for (const [o, r2] of i.properties) {
      const i2 = ye(e3, n3, r2);
      void 0 !== i2 && t5.propertyParams.set(o, i2);
    }
    return e3.node;
  }(e2, e2.node, t4) : function(e3, t5, n3) {
    const i = t5.binding.metadata;
    for (const [o, r2] of i.arguments.entries()) t5.params[o] = Me(e3, n3, r2);
    return e3.node;
  }(e2, e2.node, t4);
}
var Te;
!function(e2) {
  e2[e2.singleMandatory = 0] = "singleMandatory", e2[e2.singleOptional = 1] = "singleOptional", e2[e2.multipleMandatory = 2] = "multipleMandatory", e2[e2.multipleOptional = 3] = "multipleOptional", e2[e2.length = 4] = "length";
}(Te || (Te = {}));
var Ce = class {
  #f;
  #g;
  #m;
  #h;
  #v;
  constructor() {
    this.#f = this.#y(), this.#g = this.#y(), this.#h = this.#y(), this.#m = this.#y(), this.#v = [];
  }
  clearCache() {
    for (const e2 of this.#M()) e2.clear();
    for (const e2 of this.#v) e2.clearCache();
  }
  get(e2) {
    return void 0 === e2.name ? void 0 === e2.tag ? this.#I(this.#f, e2).get(e2.serviceIdentifier) : this.#I(this.#m, e2).get(e2.serviceIdentifier)?.get(e2.tag.key)?.get(e2.tag.value) : void 0 === e2.tag ? this.#I(this.#g, e2).get(e2.serviceIdentifier)?.get(e2.name) : this.#I(this.#h, e2).get(e2.serviceIdentifier)?.get(e2.name)?.get(e2.tag.key)?.get(e2.tag.value);
  }
  set(e2, t4) {
    void 0 === e2.name ? void 0 === e2.tag ? this.#I(this.#f, e2).set(e2.serviceIdentifier, t4) : this.#w(this.#w(this.#I(this.#m, e2), e2.serviceIdentifier), e2.tag.key).set(e2.tag.value, t4) : void 0 === e2.tag ? this.#w(this.#I(this.#g, e2), e2.serviceIdentifier).set(e2.name, t4) : this.#w(this.#w(this.#w(this.#I(this.#h, e2), e2.serviceIdentifier), e2.name), e2.tag.key).set(e2.tag.value, t4);
  }
  subscribe(e2) {
    this.#v.push(e2);
  }
  #y() {
    const e2 = new Array(Te.length);
    for (let t4 = 0; t4 < e2.length; ++t4) e2[t4] = /* @__PURE__ */ new Map();
    return e2;
  }
  #w(e2, t4) {
    let n3 = e2.get(t4);
    return void 0 === n3 && (n3 = /* @__PURE__ */ new Map(), e2.set(t4, n3)), n3;
  }
  #I(e2, t4) {
    return e2[this.#b(t4)];
  }
  #M() {
    return [...this.#f, ...this.#g, ...this.#h, ...this.#m];
  }
  #b(e2) {
    return e2.isMultiple ? true === e2.optional ? Te.multipleOptional : Te.multipleMandatory : true === e2.optional ? Te.singleOptional : Te.singleMandatory;
  }
};
function Se(e2, t4) {
  return e(t4) ? t4.then((t5) => Ae(e2, t5)) : Ae(e2, t4);
}
function Ae(e2, t4) {
  return e2.cache = { isRight: true, value: t4 }, t4;
}
function $e(e2, t4, n3) {
  const i = e2.getActivations(t4);
  return void 0 === i ? n3 : e(n3) ? xe(e2, n3, i[Symbol.iterator]()) : function(e3, t5, n4) {
    let i2 = t5, o = n4.next();
    for (; true !== o.done; ) {
      const t6 = o.value(e3.context, i2);
      if (e(t6)) return xe(e3, t6, n4);
      i2 = t6, o = n4.next();
    }
    return i2;
  }(e2, n3, i[Symbol.iterator]());
}
async function xe(e2, t4, n3) {
  let i = await t4, o = n3.next();
  for (; true !== o.done; ) i = await o.value(e2.context, i), o = n3.next();
  return i;
}
function Be(e2, t4, n3) {
  let i = n3;
  if (void 0 !== t4.onActivation) {
    const n4 = t4.onActivation;
    i = e(i) ? i.then((t5) => n4(e2.context, t5)) : n4(e2.context, i);
  }
  return $e(e2, t4.serviceIdentifier, i);
}
function Re(e2) {
  return (t4, n3) => {
    if (n3.cache.isRight) return n3.cache.value;
    return Se(n3, Be(t4, n3, e2(t4, n3)));
  };
}
var ke = Re(function(e2, t4) {
  return t4.value;
});
function Pe(e2) {
  return e2;
}
function De(e2, t4) {
  return (n3, i) => {
    const o = e2(i);
    switch (o.scope) {
      case s.Singleton:
        if (o.cache.isRight) return o.cache.value;
        return Se(o, Be(n3, o, t4(n3, i)));
      case s.Request: {
        if (n3.requestScopeCache.has(o.id)) return n3.requestScopeCache.get(o.id);
        const e3 = Be(n3, o, t4(n3, i));
        return n3.requestScopeCache.set(o.id, e3), e3;
      }
      case s.Transient:
        return Be(n3, o, t4(n3, i));
    }
  };
}
var Ve = ((e2) => De(Pe, e2))(function(e2, t4) {
  return t4.value(e2.context);
});
var Fe = Re(function(e2, t4) {
  return t4.factory(e2.context);
});
function Oe(e2, t4, n3) {
  const i = function(e3, t5, n4) {
    if (void 0 === n4) return;
    if (!(n4 in e3)) throw new b(j.resolution, `Expecting a "${n4.toString()}" property when resolving "${t5.implementationType.name}" class @postConstruct decorated method, none found.`);
    if ("function" != typeof e3[n4]) throw new b(j.resolution, `Expecting a "${n4.toString()}" method when resolving "${t5.implementationType.name}" class @postConstruct decorated method, a non function property was found instead.`);
    {
      let i2;
      try {
        i2 = e3[n4]();
      } catch (e4) {
        throw new b(j.resolution, `Unexpected error found when calling "${n4.toString()}" @postConstruct decorated method on class "${t5.implementationType.name}"`, { cause: e4 });
      }
      if (e(i2)) return async function(e4, t6, n5) {
        try {
          await n5;
        } catch (n6) {
          throw new b(j.resolution, `Unexpected error found when calling "${t6.toString()}" @postConstruct decorated method on class "${e4.implementationType.name}"`, { cause: n6 });
        }
      }(t5, n4, i2);
    }
  }(e2, t4, n3);
  return e(i) ? i.then(() => e2) : e2;
}
function Ne(e2) {
  return (t4, n3, i) => {
    const o = new i.binding.implementationType(...t4), r2 = e2(n3, o, i);
    return e(r2) ? r2.then(() => Oe(o, i.binding, i.classMetadata.lifecycle.postConstructMethodName)) : Oe(o, i.binding, i.classMetadata.lifecycle.postConstructMethodName);
  };
}
var Ee = Re(function(e2, t4) {
  return t4.provider(e2.context);
});
function Ue(e2) {
  return e2.binding;
}
function Ke(e2) {
  return e2.binding;
}
var qe = /* @__PURE__ */ function(e2) {
  return (t4, n3, i) => {
    const o = [];
    for (const [r2, s2] of i.propertyParams) {
      const c2 = i.classMetadata.properties.get(r2);
      if (void 0 === c2) throw new b(j.resolution, `Expecting metadata at property "${r2.toString()}", none found`);
      c2.kind !== C.unmanaged && void 0 !== s2.bindings && (n3[r2] = e2(t4, s2), e(n3[r2]) && o.push((async () => {
        n3[r2] = await n3[r2];
      })()));
    }
    if (o.length > 0) return Promise.all(o).then(() => {
    });
  };
}(Xe);
var ze = /* @__PURE__ */ function(e2) {
  return function t4(n3, i) {
    const o = [];
    for (const r2 of i.redirections) ue(r2) ? o.push(...t4(n3, r2)) : o.push(e2(n3, r2));
    return o;
  };
}(We);
var Ge = /* @__PURE__ */ function(e2, t4, n3) {
  return (i, o) => {
    const r2 = e2(i, o);
    return e(r2) ? t4(r2, i, o) : n3(r2, i, o);
  };
}(/* @__PURE__ */ function(e2) {
  return (t4, n3) => {
    const i = [];
    for (const o of n3.constructorParams) void 0 === o ? i.push(void 0) : i.push(e2(t4, o));
    return i.some(e) ? Promise.all(i) : i;
  };
}(Xe), /* @__PURE__ */ function(e2) {
  return async (t4, n3, i) => {
    const o = await t4;
    return e2(o, n3, i);
  };
}(Ne(qe)), Ne(qe));
var He = /* @__PURE__ */ function(e2) {
  return (t4, n3) => {
    const i = e2(t4, n3);
    return e(i) ? i.then((e3) => n3.binding.factory(...e3)) : n3.binding.factory(...i);
  };
}(/* @__PURE__ */ function(e2) {
  return (t4, n3) => {
    const i = [];
    for (const o of n3.params) i.push(e2(t4, o));
    return i.some(e) ? Promise.all(i) : i;
  };
}(Xe));
var Je = ((e2) => De(Ue, e2))(Ge);
var Le = ((e2) => De(Ke, e2))(He);
function Qe(e2) {
  return Xe(e2, e2.planResult.tree.root);
}
function We(e2, t4) {
  switch (t4.binding.type) {
    case c.ConstantValue:
      return ke(e2, t4.binding);
    case c.DynamicValue:
      return Ve(e2, t4.binding);
    case c.Factory:
      return Fe(e2, t4.binding);
    case c.Instance:
      return Je(e2, t4);
    case c.Provider:
      return Ee(e2, t4.binding);
    case c.ResolvedValue:
      return Le(e2, t4);
  }
}
function Xe(e2, t4) {
  if (void 0 !== t4.bindings) return Array.isArray(t4.bindings) ? function(e3, t5) {
    const n3 = [];
    for (const i of t5) ue(i) ? n3.push(...ze(e3, i)) : n3.push(We(e3, i));
    if (n3.some(e)) return Promise.all(n3);
    return n3;
  }(e2, t4.bindings) : function(e3, t5) {
    if (ue(t5)) {
      const n3 = ze(e3, t5);
      if (1 === n3.length) return n3[0];
      throw new b(j.resolution, "Unexpected multiple resolved values on single injection");
    }
    return We(e3, t5);
  }(e2, t4.bindings);
}
function Ye(e2) {
  return void 0 !== e2.scope;
}
function Ze(e2, t4) {
  if (void 0 !== e2.lifecycle.preDestroyMethodName && "function" == typeof t4[e2.lifecycle.preDestroyMethodName]) return t4[e2.lifecycle.preDestroyMethodName]();
}
function _e(e2, t4, n3) {
  const i = e2.getDeactivations(t4);
  if (void 0 !== i) return e(n3) ? et(n3, i[Symbol.iterator]()) : function(e3, t5) {
    let n4 = t5.next();
    for (; true !== n4.done; ) {
      const i2 = n4.value(e3);
      if (e(i2)) return et(e3, t5);
      n4 = t5.next();
    }
  }(n3, i[Symbol.iterator]());
}
async function et(e2, t4) {
  const n3 = await e2;
  let i = t4.next();
  for (; true !== i.done; ) await i.value(n3), i = t4.next();
}
function tt(e2, t4) {
  const n3 = function(e3, t5) {
    if (t5.type === c.Instance) {
      const n4 = e3.getClassMetadata(t5.implementationType), i = t5.cache.value;
      return e(i) ? i.then((e4) => Ze(n4, e4)) : Ze(n4, i);
    }
  }(e2, t4);
  return void 0 === n3 ? nt(e2, t4) : n3.then(() => nt(e2, t4));
}
function nt(e2, t4) {
  const n3 = t4.cache;
  return e(n3.value) ? n3.value.then((n4) => it(e2, t4, n4)) : it(e2, t4, n3.value);
}
function it(e2, t4, n3) {
  let i;
  if (void 0 !== t4.onDeactivation) {
    i = (0, t4.onDeactivation)(n3);
  }
  return void 0 === i ? _e(e2, t4.serviceIdentifier, n3) : i.then(() => _e(e2, t4.serviceIdentifier, n3));
}
function ot(e2, t4) {
  if (void 0 === t4) return;
  const n3 = function(e3) {
    const t5 = [];
    for (const n4 of e3) Ye(n4) && n4.scope === s.Singleton && n4.cache.isRight && t5.push(n4);
    return t5;
  }(t4), i = [];
  for (const t5 of n3) {
    const n4 = tt(e2, t5);
    void 0 !== n4 && i.push(n4);
  }
  return i.length > 0 ? Promise.all(i).then(() => {
  }) : void 0;
}
function rt(e2, t4) {
  const n3 = e2.getBindingsFromModule(t4);
  return ot(e2, n3);
}
function at(e2, t4) {
  const n3 = e2.getBindings(t4);
  return ot(e2, n3);
}

// node_modules/@inversifyjs/container/lib/esm/index.js
var f2 = "@inversifyjs/container/bindingId";
var m2 = class {
  #i;
  #e;
  constructor(n3) {
    this.#i = function() {
      const n4 = t2(Object, f2) ?? 0;
      return n4 === Number.MAX_SAFE_INTEGER ? n2(Object, f2, Number.MIN_SAFE_INTEGER) : a(Object, f2, () => n4, (i) => i + 1), n4;
    }(), this.#e = n3;
  }
  get id() {
    return this.#i;
  }
  async load(i) {
    await this.#e(i);
  }
};
var y2 = class {
  static always = (i) => true;
};
var w2 = "@inversifyjs/container/bindingId";
function I2() {
  const n3 = t2(Object, w2) ?? 0;
  return n3 === Number.MAX_SAFE_INTEGER ? n2(Object, w2, Number.MIN_SAFE_INTEGER) : a(Object, w2, () => n3, (i) => i + 1), n3;
}
function A2(i) {
  return (e2) => {
    for (let t4 = e2.getAncestor(); void 0 !== t4; t4 = t4.getAncestor()) if (i(t4)) return true;
    return false;
  };
}
function P2(i) {
  return (e2) => e2.name === i;
}
function R2(i) {
  return (e2) => e2.serviceIdentifier === i;
}
function B2(i, e2) {
  return (t4) => t4.tags.has(i) && t4.tags.get(i) === e2;
}
function C2(i) {
  return void 0 === i.name && 0 === i.tags.size;
}
function M2(i) {
  const e2 = A2(i);
  return (i2) => !e2(i2);
}
function N2(i) {
  return (e2) => {
    const t4 = e2.getAncestor();
    return void 0 === t4 || !i(t4);
  };
}
function x2(i) {
  return (e2) => {
    const t4 = e2.getAncestor();
    return void 0 !== t4 && i(t4);
  };
}
var O2 = class {
  #t;
  constructor(i) {
    this.#t = i;
  }
  inRequestScope() {
    return this.#t.scope = s.Request, new j2(this.#t);
  }
  inSingletonScope() {
    return this.#t.scope = s.Singleton, new j2(this.#t);
  }
  inTransientScope() {
    return this.#t.scope = s.Transient, new j2(this.#t);
  }
};
var F2 = class {
  #n;
  #s;
  #a;
  #o;
  constructor(i, e2, t4, n3) {
    this.#n = i, this.#s = e2, this.#a = t4, this.#o = n3;
  }
  to(i) {
    const e2 = S(i), t4 = { cache: { isRight: false, value: void 0 }, id: I2(), implementationType: i, isSatisfiedBy: y2.always, moduleId: this.#s, onActivation: void 0, onDeactivation: void 0, scope: e2.scope ?? this.#a, serviceIdentifier: this.#o, type: c.Instance };
    return this.#n(t4), new E2(t4);
  }
  toSelf() {
    if ("function" != typeof this.#o) throw new Error('"toSelf" function can only be applied when a newable function is used as service identifier');
    return this.to(this.#o);
  }
  toConstantValue(i) {
    const e2 = { cache: { isRight: false, value: void 0 }, id: I2(), isSatisfiedBy: y2.always, moduleId: this.#s, onActivation: void 0, onDeactivation: void 0, scope: s.Singleton, serviceIdentifier: this.#o, type: c.ConstantValue, value: i };
    return this.#n(e2), new j2(e2);
  }
  toDynamicValue(i) {
    const e2 = { cache: { isRight: false, value: void 0 }, id: I2(), isSatisfiedBy: y2.always, moduleId: this.#s, onActivation: void 0, onDeactivation: void 0, scope: this.#a, serviceIdentifier: this.#o, type: c.DynamicValue, value: i };
    return this.#n(e2), new E2(e2);
  }
  toResolvedValue(i, e2) {
    const t4 = { cache: { isRight: false, value: void 0 }, factory: i, id: I2(), isSatisfiedBy: y2.always, metadata: this.#r(e2), moduleId: this.#s, onActivation: void 0, onDeactivation: void 0, scope: this.#a, serviceIdentifier: this.#o, type: c.ResolvedValue };
    return this.#n(t4), new E2(t4);
  }
  toFactory(i) {
    const e2 = { cache: { isRight: false, value: void 0 }, factory: i, id: I2(), isSatisfiedBy: y2.always, moduleId: this.#s, onActivation: void 0, onDeactivation: void 0, scope: s.Singleton, serviceIdentifier: this.#o, type: c.Factory };
    return this.#n(e2), new j2(e2);
  }
  toProvider(i) {
    const e2 = { cache: { isRight: false, value: void 0 }, id: I2(), isSatisfiedBy: y2.always, moduleId: this.#s, onActivation: void 0, onDeactivation: void 0, provider: i, scope: s.Singleton, serviceIdentifier: this.#o, type: c.Provider };
    return this.#n(e2), new j2(e2);
  }
  toService(i) {
    const e2 = { id: I2(), isSatisfiedBy: y2.always, moduleId: this.#s, serviceIdentifier: this.#o, targetServiceIdentifier: i, type: c.ServiceRedirection };
    this.#n(e2);
  }
  #r(i) {
    return { arguments: (i ?? []).map((i2) => function(i3) {
      return "object" == typeof i3 && !r.is(i3);
    }(i2) ? { kind: true === i2.isMultiple ? oe.multipleInjection : oe.singleInjection, name: i2.name, optional: i2.optional ?? false, tags: new Map((i2.tags ?? []).map((i3) => [i3.key, i3.value])), value: i2.serviceIdentifier } : { kind: oe.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: i2 }) };
  }
};
var D2 = class {
  #t;
  constructor(i) {
    this.#t = i;
  }
  onActivation(i) {
    return this.#t.onActivation = i, new k2(this.#t);
  }
  onDeactivation(i) {
    return this.#t.onDeactivation = i, new k2(this.#t);
  }
};
var k2 = class {
  #t;
  constructor(i) {
    this.#t = i;
  }
  when(i) {
    return this.#t.isSatisfiedBy = i, new D2(this.#t);
  }
  whenAnyAncestor(i) {
    return this.when(A2(i));
  }
  whenAnyAncestorIs(i) {
    return this.when(A2(R2(i)));
  }
  whenAnyAncestorNamed(i) {
    return this.when(function(i2) {
      return A2(P2(i2));
    }(i));
  }
  whenAnyAncestorTagged(i, e2) {
    return this.when(function(i2, e3) {
      return A2(B2(i2, e3));
    }(i, e2));
  }
  whenDefault() {
    return this.when(C2);
  }
  whenNamed(i) {
    return this.when(P2(i));
  }
  whenNoParent(i) {
    return this.when(N2(i));
  }
  whenNoParentIs(i) {
    return this.when(N2(R2(i)));
  }
  whenNoParentNamed(i) {
    return this.when(function(i2) {
      return N2(P2(i2));
    }(i));
  }
  whenNoParentTagged(i, e2) {
    return this.when(function(i2, e3) {
      return N2(B2(i2, e3));
    }(i, e2));
  }
  whenParent(i) {
    return this.when(x2(i));
  }
  whenParentIs(i) {
    return this.when(x2(R2(i)));
  }
  whenParentNamed(i) {
    return this.when(function(i2) {
      return x2(P2(i2));
    }(i));
  }
  whenParentTagged(i, e2) {
    return this.when(function(i2, e3) {
      return x2(B2(i2, e3));
    }(i, e2));
  }
  whenTagged(i, e2) {
    return this.when(B2(i, e2));
  }
  whenNoAncestor(i) {
    return this.when(M2(i));
  }
  whenNoAncestorIs(i) {
    return this.when(M2(R2(i)));
  }
  whenNoAncestorNamed(i) {
    return this.when(function(i2) {
      return M2(P2(i2));
    }(i));
  }
  whenNoAncestorTagged(i, e2) {
    return this.when(function(i2, e3) {
      return M2(B2(i2, e3));
    }(i, e2));
  }
};
var j2 = class extends k2 {
  #c;
  constructor(i) {
    super(i), this.#c = new D2(i);
  }
  onActivation(i) {
    return this.#c.onActivation(i);
  }
  onDeactivation(i) {
    return this.#c.onDeactivation(i);
  }
};
var E2 = class extends j2 {
  #d;
  constructor(i) {
    super(i), this.#d = new O2(i);
  }
  inRequestScope() {
    return this.#d.inRequestScope();
  }
  inSingletonScope() {
    return this.#d.inSingletonScope();
  }
  inTransientScope() {
    return this.#d.inTransientScope();
  }
};
var T2 = Symbol.for("@inversifyjs/container/InversifyContainerError");
var V2 = class _V extends Error {
  [T2];
  kind;
  constructor(i, e2, t4) {
    super(e2, t4), this[T2] = true, this.kind = i;
  }
  static is(i) {
    return "object" == typeof i && null !== i && true === i[T2];
  }
  static isErrorOfKind(i, e2) {
    return _V.is(i) && i.kind === e2;
  }
};
var _2;
!function(i) {
  i[i.invalidOperation = 0] = "invalidOperation";
}(_2 || (_2 = {}));
var G2 = s.Transient;
var q2 = class {
  #l;
  #u;
  #h;
  #v;
  #g;
  #b;
  #S;
  #p;
  #f;
  #m;
  constructor(i) {
    this.#v = (i2) => this.#l.get(i2), this.#S = new Ce(), this.#p = this.#y(), void 0 === i?.parent ? (this.#l = g.build(void 0), this.#u = m.build(void 0), this.#h = h.build(void 0)) : (this.#l = g.build(i.parent.#l), this.#u = m.build(i.parent.#u), this.#h = h.build(i.parent.#h), i.parent.#S.subscribe(this.#S)), this.#g = this.#u.get.bind(this.#u), this.#f = this.#w.bind(this), this.#b = { autobind: i?.autobind ?? false, defaultScope: i?.defaultScope ?? G2 }, this.#m = [];
  }
  bind(i) {
    return new F2((i2) => {
      this.#w(i2);
    }, void 0, this.#b.defaultScope, i);
  }
  get(i, e2) {
    const t4 = this.#I(false, i, e2), n3 = this.#A(t4);
    if (e(n3)) throw new V2(_2.invalidOperation, `Unexpected asyncronous service when resolving service "${t(i)}"`);
    return n3;
  }
  getAll(i, e2) {
    const t4 = this.#I(true, i, e2), n3 = this.#A(t4);
    if (e(n3)) throw new V2(_2.invalidOperation, `Unexpected asyncronous service when resolving service "${t(i)}"`);
    return n3;
  }
  async getAllAsync(i, e2) {
    const t4 = this.#I(true, i, e2);
    return this.#A(t4);
  }
  async getAsync(i, e2) {
    const t4 = this.#I(false, i, e2);
    return this.#A(t4);
  }
  isBound(i, e2) {
    const t4 = this.#u.get(i);
    return this.#P(i, t4, e2);
  }
  isCurrentBound(i, e2) {
    const t4 = this.#u.getNonParentBindings(i);
    return this.#P(i, t4, e2);
  }
  async load(...i) {
    await Promise.all(i.map(async (i2) => i2.load(this.#R(i2.id))));
  }
  onActivation(i, e2) {
    this.#l.add(e2, { serviceId: i });
  }
  onDeactivation(i, e2) {
    this.#h.add(e2, { serviceId: i });
  }
  restore() {
    const i = this.#m.pop();
    if (void 0 === i) throw new V2(_2.invalidOperation, "No snapshot available to restore");
    this.#l = i.activationService, this.#u = i.bindingService, this.#h = i.deactivationService, this.#B();
  }
  snapshot() {
    this.#m.push({ activationService: this.#l.clone(), bindingService: this.#u.clone(), deactivationService: this.#h.clone() });
  }
  async unbind(i) {
    await at(this.#C(), i), this.#l.removeAllByServiceId(i), this.#u.removeAllByServiceId(i), this.#h.removeAllByServiceId(i), this.#S.clearCache();
  }
  async unbindAll() {
    const i = this.#C(), e2 = [...this.#u.getNonParentBoundServices()];
    await Promise.all(e2.map(async (e3) => at(i, e3)));
    for (const i2 of e2) this.#l.removeAllByServiceId(i2), this.#u.removeAllByServiceId(i2), this.#h.removeAllByServiceId(i2);
    this.#S.clearCache();
  }
  async unload(...i) {
    const e2 = this.#C();
    await Promise.all(i.map((i2) => rt(e2, i2.id)));
    for (const e3 of i) this.#l.removeAllByModuleId(e3.id), this.#u.removeAllByModuleId(e3.id), this.#h.removeAllByModuleId(e3.id);
    this.#S.clearCache();
  }
  #R(i) {
    return { bind: (e2) => new F2((i2) => {
      this.#w(i2);
    }, i, this.#b.defaultScope, e2), isBound: this.isBound.bind(this), onActivation: (e2, t4) => {
      this.#l.add(t4, { moduleId: i, serviceId: e2 });
    }, onDeactivation: (e2, t4) => {
      this.#h.add(t4, { moduleId: i, serviceId: e2 });
    }, unbind: this.unbind.bind(this) };
  }
  #C() {
    return { getBindings: (i) => this.#u.get(i), getBindingsFromModule: (i) => this.#u.getByModuleId(i), getClassMetadata: S, getDeactivations: (i) => this.#h.get(i) };
  }
  #M(i, e2, t4) {
    return { isMultiple: i, name: t4?.name, optional: t4?.optional, serviceIdentifier: e2, tag: t4?.tag };
  }
  #N(i, e2, t4) {
    const n3 = { autobindOptions: t4?.autobind ?? this.#b.autobind ? { scope: this.#b.defaultScope } : void 0, getBindings: this.#g, getClassMetadata: S, rootConstraints: { isMultiple: i, serviceIdentifier: e2 }, servicesBranch: /* @__PURE__ */ new Set(), setBinding: this.#f };
    return this.#x(n3, t4), n3;
  }
  #I(i, e2, t4) {
    const n3 = this.#M(i, e2, t4), s2 = this.#S.get(n3);
    if (void 0 !== s2) return s2;
    const a2 = he(this.#N(i, e2, t4));
    return this.#S.set(n3, a2), a2;
  }
  #y() {
    return { get: this.get.bind(this), getAll: this.getAll.bind(this), getAllAsync: this.getAllAsync.bind(this), getAsync: this.getAsync.bind(this) };
  }
  #A(i) {
    return Qe({ context: this.#p, getActivations: this.#v, planResult: i, requestScopeCache: /* @__PURE__ */ new Map() });
  }
  #x(i, e2) {
    void 0 !== e2 && (void 0 !== e2.name && (i.rootConstraints.name = e2.name), true === e2.optional && (i.rootConstraints.isOptional = true), void 0 !== e2.tag && (i.rootConstraints.tag = { key: e2.tag.key, value: e2.tag.value }));
  }
  #P(i, e2, t4) {
    if (void 0 === e2) return false;
    const n3 = { getAncestor: () => {
    }, name: t4?.name, serviceIdentifier: i, tags: /* @__PURE__ */ new Map() };
    void 0 !== t4?.tag && n3.tags.set(t4.tag.key, t4.tag.value);
    for (const i2 of e2) if (i2.isSatisfiedBy(n3)) return true;
    return false;
  }
  #B() {
    this.#S.clearCache(), this.#v = (i) => this.#l.get(i), this.#g = this.#u.get.bind(this.#u), this.#p = this.#y(), this.#f = this.#w.bind(this);
  }
  #w(i) {
    this.#u.set(i), this.#S.clearCache();
  }
};
export {
  q2 as Container,
  m2 as ContainerModule,
  r as LazyServiceIdentifier,
  s as bindingScopeValues,
  c as bindingTypeValues,
  v as decorate,
  O as inject,
  H as injectFromBase,
  K as injectable,
  J as multiInject,
  W as named,
  Y as optional,
  Z as postConstruct,
  _ as preDestroy,
  ee as tagged,
  ie as unmanaged
};
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=inversify.js.map
